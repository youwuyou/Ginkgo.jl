var documenterSearchIndex = {"docs":
[{"location":"use_ginkgo_in_julia/#Use-Ginkgo-in-Julia","page":"Use Ginkgo in Julia","title":"Use Ginkgo in Julia","text":"","category":"section"},{"location":"use_ginkgo_in_julia/","page":"Use Ginkgo in Julia","title":"Use Ginkgo in Julia","text":"How can we use a C++ library in our Julia code? In order to do this, we need to firstly create header file(s) that contain(s) C API. Then we can use Clang.jl to generate low-level API from it. The remaining step would be to properly wrap these low-level API methods using a higher-level API, such that users in Julia community can use our newly created Julia wrapper package as if it was a native package. Following is a workflow diagram that illustrates the whole process.","category":"page"},{"location":"use_ginkgo_in_julia/","page":"Use Ginkgo in Julia","title":"Use Ginkgo in Julia","text":"(Image: Using C++ code in Julia)","category":"page"},{"location":"use_ginkgo_in_julia/#Understanding-how-Julia-functions-are-involved","page":"Use Ginkgo in Julia","title":"Understanding how Julia functions are involved","text":"","category":"section"},{"location":"use_ginkgo_in_julia/","page":"Use Ginkgo in Julia","title":"Use Ginkgo in Julia","text":"We consider a function integrate() that performs numerical integration in our C++ library. Within the header file that contains the C API, the function declaration lies within braces of the language linkage specified with an extern \"C\" keyword. The use of this keyword disables name mangling for specified functions in C++, such that the client linker will be able to link using the C name as how you specified within the code.","category":"page"},{"location":"use_ginkgo_in_julia/","page":"Use Ginkgo in Julia","title":"Use Ginkgo in Julia","text":"extern \"C\" {\n\ndouble integrate(const double a,\n                 const double b,\n                 const unsigned bins,\n                 double (*function)(double));\n\n\n// other methods...\n\n}","category":"page"},{"location":"use_ginkgo_in_julia/#.-Analyzing-Compiled-C-Shared-Libraries","page":"Use Ginkgo in Julia","title":"1. Analyzing Compiled C++ Shared Libraries","text":"","category":"section"},{"location":"use_ginkgo_in_julia/","page":"Use Ginkgo in Julia","title":"Use Ginkgo in Julia","text":"Let us suppose we have already compiled and linked our code into a shared library called libname.so. It is now essential to understand what information does the compiled shared library provides. An important tool is nm for displaying symbol table of an object, library or executable files. Using the following command nm -D libname.so, we would be able to have a peek into the shared library even without access to the source code.","category":"page"},{"location":"use_ginkgo_in_julia/","page":"Use Ginkgo in Julia","title":"Use Ginkgo in Julia","text":"Following is an example outcome:","category":"page"},{"location":"use_ginkgo_in_julia/","page":"Use Ginkgo in Julia","title":"Use Ginkgo in Julia","text":"$ nm -D libname.so\n                 U __assert_fail@GLIBC_2.2.5\n                 w __cxa_finalize@GLIBC_2.2.5\n0000000000001307 T get_version\n                 w __gmon_start__\n0000000000001129 T integrate\n                 w _ITM_deregisterTMCloneTable\n                 w _ITM_registerTMCloneTable\n                 U _ZNSolsEPFRSoS_E@GLIBCXX_3.4\n                 U _ZSt21ios_base_library_initv@GLIBCXX_3.4.32\n                 U _ZSt4cout@GLIBCXX_3.4\n                 U _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_@GLIBCXX_3.4\n                 U _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@GLIBCXX_3.4","category":"page"},{"location":"use_ginkgo_in_julia/","page":"Use Ginkgo in Julia","title":"Use Ginkgo in Julia","text":"As the line 0000000000001129 T integrate suggests, the function we previously defined can be referenced by the dynamic linker using the symbol name integrate at a specific address 0x1129 in the shared library. The exact same name will be needed by the dynamic linker of Julia, when the shared library will be dynamically linked ","category":"page"},{"location":"use_ginkgo_in_julia/#.-Utilizing-ccall-for-Run-time-Calls-to-Shared-Library-Functions-in-Julia","page":"Use Ginkgo in Julia","title":"2. Utilizing ccall for Run-time Calls to Shared Library Functions in Julia","text":"","category":"section"},{"location":"use_ginkgo_in_julia/","page":"Use Ginkgo in Julia","title":"Use Ginkgo in Julia","text":"In our Julia program, we can invoke the integrate() function that we have compiled and linked into the libname.so shared library with ccall syntax. Note that the use of the ccall is like calling a function, but it is essentially a special keyword for calling function in C-exported shared library.","category":"page"},{"location":"use_ginkgo_in_julia/","page":"Use Ginkgo in Julia","title":"Use Ginkgo in Julia","text":"# contained in autogenerated low-level API\nfunction integrate(a, b, bins, _function)\n    ccall((:integrate, libname), Cdouble, (Cdouble, Cdouble, Cuint, Ptr{Cvoid}), a, b, bins, _function)\nend","category":"page"},{"location":"use_ginkgo_in_julia/","page":"Use Ginkgo in Julia","title":"Use Ginkgo in Julia","text":"The invokation of the ccall syntax specifies the shared library name and the C-exported function name that we would like to invoke. It is important to note that the function name which we specify here must be identical to what we have in the symbol table. For debugging purposes, we can also use the tool nm to look up the symbol table in order to make sure there is no name mangling.","category":"page"},{"location":"use_ginkgo_in_julia/","page":"Use Ginkgo in Julia","title":"Use Ginkgo in Julia","text":"Then the remaining work is to provide a decent high-level wrapper function such that the users of our Ginkgo.jl package can call this function correctly. Then the JIT compiler will handle the rest.","category":"page"},{"location":"use_ginkgo_in_julia/#How-about-performance?","page":"Use Ginkgo in Julia","title":"How about performance?","text":"","category":"section"},{"location":"use_ginkgo_in_julia/","page":"Use Ginkgo in Julia","title":"Use Ginkgo in Julia","text":"Regarding the concerns if overhead would be brought by adding this layer. We cite the following information from the official Julia documentation in the section Calling C and Fortran code.","category":"page"},{"location":"use_ginkgo_in_julia/","page":"Use Ginkgo in Julia","title":"Use Ginkgo in Julia","text":"The machine instructions generated by Julia's JIT are the same as a native C call would be, so the resulting overhead is the same as calling a library function from C code. Non-library function >calls in both C and Julia can be inlined and thus may have even less overhead than calls to shared library functions. The point above is that the cost of actually doing foreign function call is >about the same as doing a call in either native language.","category":"page"},{"location":"api/#Low-level-API","page":"Reference","title":"Low-level API","text":"","category":"section"},{"location":"api/","page":"Reference","title":"Reference","text":"The Ginkgo.API submodule provides a low-level interface which closely matches the Ginkgo C API. While these functions are not intended for general usage, they are useful for calling Ginkgo routines not yet available in Ginkgo.jl main interface, and is the basis for the high-level wrappers. For illustrative purpose, we use a example api.jl here, yet to be replaced.","category":"page"},{"location":"api/","page":"Reference","title":"Reference","text":"Modules = [Ginkgo.API]\nOrder = [:function]","category":"page"},{"location":"api/#Ginkgo.API.get_version-Tuple{}","page":"Reference","title":"Ginkgo.API.get_version","text":"get_version()\n\nGet the version of the package\n\n\n\n\n\n","category":"method"},{"location":"api/#Ginkgo.API.integrate-NTuple{4, Any}","page":"Reference","title":"Ginkgo.API.integrate","text":"integrate(a, b, bins, _function)\n\nIntegrate over a given function given by a function pointer function\n\nParameters\n\na: double\nb: double\nbins: a positive integer\nfunction: a pointer to a function\n\nReturns\n\ndouble\n\n\n\n\n\n","category":"method"},{"location":"reindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"reindex/","page":"Index","title":"Index","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Ginkgo","category":"page"},{"location":"#Ginkgo.jl","page":"Home","title":"Ginkgo.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ginkgo.jl is a Julia wrapper for the high-performance numerical linear algebra library Ginkgo that aims to leverage the hardware vendor’s native programming models to implement highly tuned architecture-specific kernels. Separating the core algorithm from these architecture- specific kernels enables high performance while enhancing the readability and maintain- ability of the software. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is the main page of the user documentation for Ginkgo.jl.","category":"page"},{"location":"ginkgo_c_library_api/#Ginkgo-C-Library-API","page":"Ginkgo C Library API","title":"Ginkgo C Library API","text":"","category":"section"},{"location":"ginkgo_c_library_api/#Correctly-wrapping-C-functions","page":"Ginkgo C Library API","title":"Correctly wrapping C++ functions","text":"","category":"section"},{"location":"ginkgo_c_library_api/#How-are-C-types-represented-in-Julia","page":"Ginkgo C Library API","title":"How are C++ types represented in Julia","text":"","category":"section"},{"location":"ginkgo_c_library_api/","page":"Ginkgo C Library API","title":"Ginkgo C Library API","text":"TODO: talk about the macro approach (metaprogramming)","category":"page"},{"location":"ginkgo_c_library_api/","page":"Ginkgo C Library API","title":"Ginkgo C Library API","text":"<!– Julia offers metaprogramming capabilities where you can define macros to abstract away certain repetitive tasks. For instance, you could define a macro that automatically generates the needed cfunction code: –>","category":"page"},{"location":"ginkgo_c_library_api/","page":"Ginkgo C Library API","title":"Ginkgo C Library API","text":"We notice the 4th argument is of type Ptr{Cvoid}, which represents a generic pointer in Julia, analogous to void* in C. In fact, when interfacing with C libraries in Julia, function pointers are typically represented using the more generic typePtr{Cvoid}, allowing better callback flexibility.","category":"page"},{"location":"ginkgo_c_library_api/","page":"Ginkgo C Library API","title":"Ginkgo C Library API","text":"TODO: debugging with escaping problem","category":"page"},{"location":"ginkgo_c_library_api/#How-to-handle-C-specific-language-features","page":"Ginkgo C Library API","title":"How to handle C++-specific language features","text":"","category":"section"},{"location":"ginkgo_c_library_api/#How-to-exploit-the-power-of-meta-programming-in-Julia-for-API","page":"Ginkgo C Library API","title":"How to exploit the power of meta programming in Julia for API","text":"","category":"section"}]
}
